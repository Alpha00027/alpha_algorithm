# 96. 不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

    1         3     3      2      1
     \       /     /      / \      \
      3     2     1      1   3      2
     /     /       \                 \
    2     1         2                 3

题解：

初看没有什么思路。先进行简单的演算，进行归纳，首先我们定义树的数量是F(i)

n = 1:

    1

F(1) = 1

n = 2:

    1          2
     \        /
      2      1

F(2) = 2

n = 3:

    1         3     3      2      1
     \       /     /      / \      \
      3     2     1      1   3      2
     /     /       \                 \
    2     1         2                 3

F(3) = 5

简单发现一点规律，下面进行规律总结：

当n=3时：

1. 根节点是1，只有右子树，右子树上有2个元素，右子树上可以构建出2个树
2. 根节点是3，只有左子树，左子树上有2个元素，左子树上可以构建出2个树
3. 根节点是2，左子树上是比2小的值，有1个值，右子树是比2大的值，有1个值

扩展到n时，我们定义树的数量是F(i)：

1. 根节点是1，只有右子树，右子树上有n-1个元素，右子树上可以构建出F(n-1)个树
2. 根节点是n，只有左子树，左子树上有n-1个元素，左子树上可以构建出F(n-1)个树
3. 根节点是i，左子树上是比i小的值，有i-1个值，左子树上可以构建F(i-1)个树，右子树是比i大的值，有n-i个值，右子树上可以构建F(n-i)个树。那么根节点是i时，树的数量为F(i-1)*F(n-i)

树的总数量 = 根节点是1 + 根节点是n + 根节点是2->n-1

$$
F(n) = F(n-1) + F(n-1) + \sum_{i=2}^{n-1}F(i-1)*F(n-i)
$$

当根节点是i（非1，非n）时，树的数量为左子树数量*右子树数量

为简化计算，我们可以规定，如果没有左右子树，则认为数量为1，即F(0) = 1

那么就有：

$$
F(n) = \sum_{i=1}^{n}F(i-1)*F(n-i)
$$

初始条件为：

    F(0) = 1;
    F(1) = 1;

同时利用上述公式简要计算，发现n=2,n=3的情况符合之前的推理。

    F(2) = F(0)*F(1) + F(1)*F(0) = 1+1 = 2
    F(3) = F(0)*F(2) + F(1)*F(1) + F(2)*F(0) = 2+1+2 = 5

写代码如下：

```
int numTrees(int n)
{
    if (n <= 0)
        return 0;

    vector<int> f(n+1,0);
    f[0] = 1;

    for (int index = 1; index <= n; index++) // index:1->n
    {
        // sum
        for (int i = 1; i <= index; i++) // i:1->index
        {
            f[index] = f[index] + f[i - 1] * f[index - i];
        }
    }

    return f[n];
}
```